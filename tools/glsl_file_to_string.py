import argparse
import logging
import os.path
import pathlib
import shutil
from datetime import datetime, timezone
from typing import IO

from tools.logger import Logger

logger = Logger.get(logging.INFO)


def remove_cache() -> None:
    shutil.rmtree("glsl_cache")


def snake_to_pascal(string: str) -> str:
    return "".join(word.capitalize() for word in string.split("_"))


def main() -> None:
    program_name, path_to_shaders, shader_stages = parse_arguments()

    if not path_to_shaders.exists():
        raise FileNotFoundError(
            "path to shaders does not exist: " + str(path_to_shaders)
        )

    need_to_generate = False
    for stage in shader_stages:
        if check_last_modification_time(
            path_to_shaders, program_name + "." + stage + ".glsl"
        ):
            need_to_generate = True

    if not need_to_generate:
        logger.debug("{program_name}.hpp not updated")
        return

    logger.info("generating: {program_name}")

    with pathlib.Path(path_to_shaders / str(program_name + ".hpp")).open(
        "w", encoding="utf-8"
    ) as output_source:
        write_header(output_source)

        output_source.write("namespace gfx::graphics::shaders\n{\n")
        output_source.write("struct " + snake_to_pascal(program_name) + "\n{\n")

        for stage in shader_stages:
            with pathlib.Path(path_to_shaders / f"{program_name}.{stage}.glsl").open(
                encoding="utf-8"
            ) as input_file:
                write_shader(output_source, stage, input_file)

        output_source.write("};\n")
        output_source.write("}\n")
        output_source.write("\n// clang-format on\n")


def parse_arguments() -> tuple[str, pathlib.Path, list[str]]:
    parser = argparse.ArgumentParser(
        description="--Generate GLSL source code strings from files\n"
        "--Expected files:\n"
        "--SHADERSPATH/program_name.SHADERSTAGE.glsl\n",
        formatter_class=argparse.RawTextHelpFormatter,
    )

    parser.add_argument(
        "--program-name",
        dest="program_name",
        help="name of the shader program with vertex and fragment shader stages",
    )

    parser.add_argument(
        "--shaders-path", dest="shadersPath", help="path to directory with shader files"
    )

    parser.add_argument(
        "--shader-stages",
        dest="shader_stages",
        help="vertex, fragment, compute, ",
        nargs="+",
    )

    args = parser.parse_args()

    if args.program_name is None:
        msg = "Missing program name"
        raise ValueError(msg)

    if args.shadersPath is None:
        msg = "Missing shaders path"
        raise ValueError(msg)

    if args.shader_stages is None:
        msg = "Missing shader stages"
        raise ValueError(msg)

    return (str(args.program_name), pathlib.Path(args.shadersPath), args.shader_stages)


def write_header(output: IO[str]) -> None:
    output.write("// do not edit this file\n")
    output.write("// generated using glsl_file_to_string.py\n")
    output.write(
        "// " + datetime.now(tz=timezone.utc).strftime("%Y-%m-%d %H:%M:%S") + "\n"
    )
    output.write("\n#pragma once\n\n")
    output.write("// clang-format off\n\n")


def write_shader(output_file: IO[str], shader_type: str, input_file: IO[str]) -> None:
    declaration = "constexpr static const char* const " + shader_type + " = "
    whitespace = " " * 4
    output_file.write(declaration + "\n")
    lines = input_file.read().splitlines()
    output_file.write(whitespace + '"' + lines[0] + '\\n"\n')

    for line in lines[1:-1]:
        output_file.write(whitespace + '"' + line + '\\n"\n')

    output_file.write(whitespace + '"' + lines[-1] + '\\n";\n')
    output_file.write("\n")


def check_last_modification_time(directory_path: pathlib.Path, filename: str) -> bool:
    cache_dir = pathlib.Path("glsl_cache")
    if not cache_dir.exists():
        cache_dir.mkdir()

    cache_file = cache_dir / str(filename + ".txt")
    if not cache_file.exists():
        mtime = os.path.getmtime(directory_path / filename)
        with cache_file.open("w", encoding="utf-8") as cache_file_descriptor:
            cache_file_descriptor.write(str(mtime))
        return True

    with cache_file.open(encoding="utf-8") as cache_file_descriptor:
        previousmtime = cache_file_descriptor.read()

    currentmtime = os.path.getmtime(directory_path / filename)

    time_threshold = 1.0
    if (currentmtime - float(previousmtime)) > time_threshold:
        with cache_file.open("w", encoding="utf-8") as cache_file_descriptor:
            cache_file_descriptor.write(str(currentmtime))

        return True

    return False


if __name__ == "__main__":
    try:
        main()
    except Exception:  # pylint: disable=broad-except
        remove_cache()
        logger.exception("removed glsl cache due to exception")
